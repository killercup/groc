<!DOCTYPE html><html lang="en"><head><title>utils/style_helpers</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="utils/style_helpers"><meta name="groc-project-path" content="lib/utils/style_helpers.coffee"><meta name="groc-github-url" content="https://github.com/nevir/groc"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/nevir/groc/blob/master/lib/utils/style_helpers.coffee">lib/utils/style_helpers.coffee</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper">path = <span class="built_in">require</span> <span class="string">'path'</span>

_ = <span class="built_in">require</span> <span class="string">'underscore'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h1 id="style-helpers">Style Helpers</h1>

<p>A collection of helpful functions to support styles and their behavior.</p></div></div><div class="code"><div class="wrapper">module.<span class="built_in">exports</span> = StyleHelpers =</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate a table of contents as a tree of {node: {...}, children: []} objects.
We want a pretty complex hierarchy in our table of contents:
buildTableOfContents: (files) -></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given an array of markdowned segments, convert their list of headers into a hierarchical
outline (table of contents!)</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">outlineHeaders</span>: <span class="function"><span class="params">(segments)</span> -&gt;</span>
    headers = segments.reduce <span class="function"><span class="params">( (a, s) -&gt; a.concat s.headers )</span>, []
    <span class="title">return</span> [] <span class="title">unless</span> <span class="title">headers</span>.<span class="title">length</span> &gt; 0

    <span class="title">nodes</span> = []
    <span class="title">for</span> <span class="title">header</span> <span class="title">in</span> <span class="title">headers</span>
      <span class="title">nodes</span>.<span class="title">push</span>
        <span class="title">type</span>: '<span class="title">heading</span>'
        <span class="title">data</span>:  <span class="title">header</span>
        <span class="title">depth</span>: <span class="title">header</span>.<span class="title">level</span>

    @<span class="title">buildNodeTree</span> <span class="title">nodes</span>
</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate a table of contents as a tree of {..., children: []} objects.
We take a list of file info objects, and a map of outlines to fileInfo.targetPath.
We want a pretty complex hierarchy in our table of contents:</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">buildTableOfContents</span>: <span class="function"><span class="params">(files, outlines)</span> -&gt;</span>
    files = files.sort <span class="function"><span class="params">(a, b)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>The index is always first in the table of contents.</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> a.targetPath == <span class="string">'index'</span>
      <span class="keyword">return</span>  <span class="number">1</span> <span class="keyword">if</span> b.targetPath == <span class="string">'index'</span>

      <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> a.targetPath == b.targetPath</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>files matching a directory name come directly before it.  E.g. "foo" &lt; "foo/bar" &lt; "foz"</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="keyword">if</span> a.targetPath &lt; b.targetPath <span class="keyword">then</span> -<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>

    nodes    = []
    prevPath = []
    <span class="keyword">for</span> file <span class="keyword">in</span> files
      targetChunks = file.targetPath.split path.join(<span class="string">'/'</span>)
      pathChunks   = targetChunks[<span class="number">0.</span>..-<span class="number">1</span>]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>If a file has the same name as a directory, it takes ownership of that directory's folder.</li>
</ul></div></div><div class="code"><div class="wrapper">      <span class="keyword">for</span> chunk, i <span class="keyword">in</span> pathChunks
        <span class="keyword">if</span> prevPath[i] != chunk</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ul>
<li>Otherwise we have a generic folder node that takes its place in the table of contents.
TODO: We probably want some way to rename folders!</li>
</ul></div></div><div class="code"><div class="wrapper">          nodes.push
            <span class="attribute">type</span>:  <span class="string">'folder'</span>
            <span class="attribute">data</span>:
              <span class="attribute">path</span>:  targetChunks[<span class="number">0.</span>.i].join <span class="string">'/'</span>
              <span class="attribute">title</span>: <span class="keyword">if</span> chunk == <span class="string">'index'</span> <span class="keyword">and</span> i <span class="keyword">is</span> <span class="number">0</span> <span class="keyword">then</span> file.pageTitle <span class="keyword">else</span> targetChunks[i]
            <span class="attribute">depth</span>: i + <span class="number">1</span>

          prevPath = [] <span class="comment"># Make sure that we don't match directories several levels in, after a fail.</span>

      prevPath = targetChunks

      fileData = _(file).clone()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Annotate the file data with a title to represent it.
If possible, we use the initial header in the file,</p></div></div><div class="code"><div class="wrapper">      <span class="keyword">if</span> outlines[file.targetPath]?[<span class="number">0</span>]?.data?.isFileHeader
        fileData.firstHeader = outlines[file.targetPath].shift()
        fileData.title       = fileData.firstHeader.data.title

        <span class="keyword">if</span> fileData.firstHeader.children?.length &gt; <span class="number">0</span>
          outlines[file.targetPath] = fileData.firstHeader.children.concat outlines[file.targetPath]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise we just fall back to the file's target path...</p></div></div><div class="code"><div class="wrapper">      <span class="keyword">else</span>
        fileData.title = <span class="keyword">if</span> file.targetPath == <span class="string">'index'</span> <span class="keyword">then</span> file.pageTitle <span class="keyword">else</span> path.basename file.targetPath

      nodes.push
        <span class="attribute">type</span>:   <span class="string">'file'</span>
        <span class="attribute">data</span>:    fileData
        <span class="attribute">depth</span>:   file.targetPath.split( path.join(<span class="string">'/'</span>) ).length
        <span class="attribute">outline</span>: outlines[file.targetPath]

    <span class="property">@buildNodeTree</span> nodes</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take a flat, though ordered, list of nodes and convert them into a tree.
Nodes are expected to have a <code>depth</code> property.  Each node is annotated with an array of
<code>children</code> if it does not exist.  Children are appended, otherwise.</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">buildNodeTree</span>: <span class="function"><span class="params">(nodes)</span> -&gt;</span>
    result = []
    stack  = []

    <span class="keyword">for</span> node <span class="keyword">in</span> nodes</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unwind the stack until we get to the first node that is at a lower depth than us.  We are
considered to be its child</p></div></div><div class="code"><div class="wrapper">      stack.pop() <span class="keyword">while</span> _(stack).last()?.depth &gt;= node.depth

      <span class="keyword">if</span> stack.length == <span class="number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Top level nodes are directly returned in the result list.</p></div></div><div class="code"><div class="wrapper">        result.push node
      <span class="keyword">else</span>
        _(stack).last().children ||= []
        _(stack).last().children.push node

      stack.push node

    result</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It helps visually to separate headers that are not attached to other comments into their own
segment.</p></div></div><div class="code"><div class="wrapper">  <span class="attribute">segmentizeSoloHeaders</span>: <span class="function"><span class="params">(segments)</span> -&gt;</span>
    results = []
    <span class="keyword">for</span> segment <span class="keyword">in</span> segments
      headerOnly = segment.markdownedComments.match <span class="regexp">/^\s*&lt;h\d[^&gt;]*&gt;[^&lt;]*&lt;\/h\d&gt;\s*$/</span>
      <span class="keyword">if</span> headerOnly <span class="keyword">and</span> <span class="keyword">not</span> segment.highlightedCode.match <span class="regexp">/^\s*$/</span>
        results.push
          <span class="attribute">code</span>:               []
          <span class="attribute">comments</span>:           segment.comments
          <span class="attribute">highlightedCode</span>:    <span class="string">''</span>
          <span class="attribute">markdownedComments</span>: segment.markdownedComments

        results.push
          <span class="attribute">code</span>:               segment.code
          <span class="attribute">comments</span>:           []
          <span class="attribute">highlightedCode</span>:    segment.highlightedCode
          <span class="attribute">markdownedComments</span>: <span class="string">''</span>

      <span class="keyword">else</span>
        results.push segment

    results</div></div></div></div></body></html>